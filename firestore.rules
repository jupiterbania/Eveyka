/**
 * @fileoverview Firestore Security Rules for FocusFinds application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user identity and defined roles.
 * It uses a combination of ownership-based access control and role-based access control where
 * appropriate. Data shape validation is minimized to allow for rapid prototyping.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information, accessible only to the user and admins.
 * - /images/{imageId}: Stores image metadata, publicly readable, owner-only writable.
 * - /users/{userId}/purchases/{purchaseId}: Stores purchase history for each user.
 * - /images/{imageId}/purchases/{purchaseId}: Stores anonymous purchase data for an image, for admin analytics.
 * - /roles_admin/{userId}: Grants admin privileges to a user.
 *
 * Key Security Decisions:
 * - Listing all documents in the root collection is forbidden due to the risk of exposing sensitive data or
 *   creating performance issues.  The error reported in `src/firebase/firestore/use-collection.tsx (94:33)`
 *   is due to this.
 * - Image metadata is publicly readable to support discovery, but write access is restricted to the owner.
 * - Admin privileges are granted based on the existence of a document in the `roles_admin` collection.
 *
 * Denormalization for Authorization:
 * - The rules rely on the `request.auth.uid` to determine the current user.  No external document lookups are performed.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Prevents listing all documents in the database root.
     * @path /databases/{database}/documents
     * @allow None - Listing root collection is always denied.
     * @deny (list) - All attempts to list the root collection.
     * @principle Prevents unintended data exposure and performance issues by blocking root collection listing.
     */
    match /{document=**} {
      allow list: if false;
    }

    /**
     * @description Manages user profile information. Accessible only to the user and admins.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     * @allow (get) User with ID 'user123' can read their profile. Admin can read any profile.
     * @allow (update) User with ID 'user123' can update their profile. Admin can update any profile.
     * @allow (delete) User with ID 'user123' can delete their profile. Admin can delete any profile.
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     * @deny (get) User with ID 'user456' cannot read 'user123' profile if not admin.
     * @principle Enforces document ownership for writes, allows admin override.
     */
    match /users/{userId} {
      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if false;
      allow update: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow delete: if isSignedIn() && (isOwner(userId) || isAdmin());
    }

    /**
     * @description Manages image metadata. Publicly readable, owner-only writable.
     * @path /images/{imageId}
     * @allow (get) Any user can read image metadata.
     * @allow (list) Any user can list images.
     * @allow (create) User with ID 'user123' can create an image with authorId 'user123'.
     * @allow (update) User with ID 'user123' can update image 'image456' if they are the author.
     * @allow (delete) User with ID 'user123' can delete image 'image456' if they are the author.
     * @deny (create) User with ID 'user456' cannot create an image with authorId 'user123'.
     * @deny (update) User with ID 'user456' cannot update image 'image456' if they are not the author.
     * @principle Allows public read access with owner-only writes, validates creatorId on create.
     */
    match /images/{imageId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // && request.resource.data.authorId == request.auth.uid; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores purchase history for each user.
     * @path /users/{userId}/purchases/{purchaseId}
     * @allow (create) User with ID 'user123' can create a purchase record.
     * @allow (get) User with ID 'user123' can read their purchase record.
     * @allow (list) User with ID 'user123' can list their purchase records.
     * @allow (update) User with ID 'user123' can update their purchase record.
     * @allow (delete) User with ID 'user123' can delete their purchase record.
     * @deny (create) User with ID 'user456' cannot create a purchase record for 'user123'.
     * @deny (get) User with ID 'user456' cannot read 'user123' purchase record.
     * @principle Enforces document ownership for writes, validates user ID on create.
     */
    match /users/{userId}/purchases/{purchaseId} {
      allow create: if isSignedIn() && isOwner(userId);
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Stores anonymous purchase data for an image, for admin analytics.
     * @path /images/{imageId}/purchases/{purchaseId}
     * @allow (create) Admin can create a purchase record for an image.
     * @allow (get) Admin can read a purchase record for an image.
     * @allow (list) Admin can list purchase records for an image.
     * @allow (update) Admin can update a purchase record for an image.
     * @allow (delete) Admin can delete a purchase record for an image.
     * @deny (create) User with ID 'user123' cannot create a purchase record for an image if not admin.
     * @deny (get) User with ID 'user123' cannot read a purchase record for an image if not admin.
     * @principle Restricts access to admins only.
     */
    match /images/{imageId}/purchases/{purchaseId} {
      allow create: if isSignedIn() && isAdmin();
      allow get: if isSignedIn() && isAdmin();
      allow list: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Stores administrator roles. Existence of a document grants admin privileges. DBAC - Existence over Content.
     * @path /roles_admin/{userId}
     * @allow (create) Any authenticated user can request admin privileges.
     * @allow (get) Any authenticated user can check if they have admin privileges.
     * @allow (list) Not allowed.
     * @allow (update) Only an existing admin can grant admin privileges.
     * @allow (delete) Only an existing admin can revoke admin privileges.
     * @deny (create) An unauthenticated user cannot request admin privileges.
     *
     * @principle Role-based access control via document existence.
     */
    match /roles_admin/{userId} {
      allow create: if isSignedIn();
      allow get: if isSignedIn();
      allow list: if false;
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description A singleton document for global site settings like the hero image.
     * @path /settings/main
     * @allow (get) Any user can read the settings document.
     * @allow (list) Not allowed - singleton.
     * @allow (create) Admin only.
     * @allow (update) Admin only.
     * @allow (delete) Admin only.
     * @deny (create) Non-admins cannot create this document.
     *
     * @principle Global settings accessible to all users, admin-only modifications.
     */
    match /settings/main {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    function isExistingOwner(userId) {
        return (isOwner(userId) && resource != null);
    }
  }
}